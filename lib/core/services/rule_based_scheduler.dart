import 'package:isar/isar.dart';
import '../../data/models/goal.dart';
import '../../data/models/one_time_task.dart';
import '../../data/models/scheduled_task.dart';
import '../../data/repositories/goal_repository.dart';
import '../../data/repositories/one_time_task_repository.dart';
import '../../data/repositories/scheduled_task_repository.dart';
import 'daily_activity_service.dart';

/// Represents a time slot in the schedule
class TimeSlot {
  final DateTime start;
  final DateTime end;

  TimeSlot(this.start, this.end);

  int get durationMinutes => end.difference(start).inMinutes;

  bool canFit(int requiredMinutes) => durationMinutes >= requiredMinutes;

  @override
  String toString() =>
      'TimeSlot(${start.hour}:${start.minute.toString().padLeft(2, '0')} - ${end.hour}:${end.minute.toString().padLeft(2, '0')}, ${durationMinutes}min)';
}

/// Rule-based scheduler - fallback when ML doesn't have enough data
class RuleBasedScheduler {
  final Isar isar;
  final GoalRepository goalRepository;
  final OneTimeTaskRepository oneTimeTaskRepository;
  final ScheduledTaskRepository scheduledTaskRepository;
  final DailyActivityService? dailyActivityService;

  // Default scheduling constraints (used if no DailyActivityService)
  static const int defaultDayStartHour = 6; // 6 AM
  static const int defaultDayEndHour = 23; // 11 PM
  static const int minTaskGapMinutes = 15; // Buffer between tasks

  RuleBasedScheduler({
    required this.isar,
    required this.goalRepository,
    required this.oneTimeTaskRepository,
    required this.scheduledTaskRepository,
    this.dailyActivityService,
  });

  /// Main scheduling method - generates schedule for a specific date
  Future<List<ScheduledTask>> scheduleForDate(DateTime date) async {
    // 1. Get goals that should be scheduled for this day
    final goals = await _getActiveGoalsForDate(date);

    if (goals.isEmpty) {
      return [];
    }

    // 2. Get blockers (one-time tasks that block time slots)
    final blockers = await _getBlockersForDate(date);

    // 3. Calculate available time slots (using dynamic wake/sleep times)
    final availableSlots = await calculateAvailableSlotsAsync(date, blockers);

    // 4. Schedule each goal in priority order
    final scheduledTasks = <ScheduledTask>[];
    final usedSlots = <TimeSlot>[];

    for (final goal in goals) {
      // Find best slot
      final bestSlot = findBestSlotForGoal(
        goal: goal,
        availableSlots: availableSlots,
        usedSlots: usedSlots,
      );

      if (bestSlot != null) {
        // Create task
        final task = ScheduledTask()
          ..goalId = goal.id
          ..title = goal.title
          ..scheduledDate = DateTime(date.year, date.month, date.day)
          ..scheduledStartTime = bestSlot.start
          ..originalScheduledTime = bestSlot.start
          ..duration = goal.targetDuration
          ..colorHex = goal.colorHex
          ..iconName = goal.iconName
          ..schedulingMethod = 'rule-based'
          ..mlConfidence = null
          ..isCompleted = false
          ..wasRescheduled = false
          ..rescheduleCount = 0
          ..isAutoGenerated = true
          ..createdAt = DateTime.now();

        scheduledTasks.add(task);
        markSlotAsUsed(task, usedSlots);
      }
    }

    return scheduledTasks;
  }

  /// Get goals that should be scheduled for this specific date
  Future<List<Goal>> _getActiveGoalsForDate(DateTime date) async {
    final allGoals = await goalRepository.getAllGoals();
    final dateOnly = DateTime(date.year, date.month, date.day);

    // Filter goals by frequency and creation date
    final goalsForDate = allGoals.where((goal) {
      // Only schedule active goals
      if (!goal.isActive) return false;
      
      // Don't schedule goals created after this date
      final goalCreatedDate = DateTime(
        goal.createdAt.year,
        goal.createdAt.month,
        goal.createdAt.day,
      );
      if (goalCreatedDate.isAfter(dateOnly)) return false;

      return _shouldScheduleGoalOnDate(goal, date);
    }).toList();

    // Sort by priority (lower index = higher priority)
    goalsForDate.sort((a, b) => a.priorityIndex.compareTo(b.priorityIndex));

    return goalsForDate;
  }

  /// Check if a goal should be scheduled on a specific date based on frequency
  bool _shouldScheduleGoalOnDate(Goal goal, DateTime date) {
    if (goal.frequency.isEmpty) return false;

    // Convert DateTime.weekday (1=Monday, 7=Sunday) to our format (0=Monday, 6=Sunday)
    final dayOfWeek = date.weekday - 1;

    // Check if this day is in the goal's frequency list
    return goal.frequency.contains(dayOfWeek);
  }

  /// Get one-time tasks that act as blockers for this date
  Future<List<OneTimeTask>> _getBlockersForDate(DateTime date) async {
    return await oneTimeTaskRepository.getOneTimeTasksForDate(date);
  }

  /// Get dynamic day start hour (learned or profile-based or default)
  Future<int> _getDayStartHour(DateTime date) async {
    if (dailyActivityService != null) {
      return await dailyActivityService!.getEffectiveWakeHour(date);
    }
    return defaultDayStartHour;
  }

  /// Get dynamic day end hour (learned or profile-based or default)
  Future<int> _getDayEndHour(DateTime date) async {
    if (dailyActivityService != null) {
      return await dailyActivityService!.getEffectiveSleepHour(date);
    }
    return defaultDayEndHour;
  }

  /// Calculate available time slots after removing blockers (PUBLIC)
  /// Uses default times - for async version use calculateAvailableSlotsAsync
  List<TimeSlot> calculateAvailableSlots(
    DateTime date,
    List<OneTimeTask> blockers, {
    int? startHour,
    int? endHour,
  }) {
    // Use provided hours or defaults
    final dayStartHour = startHour ?? defaultDayStartHour;
    var dayEndHour = endHour ?? defaultDayEndHour;

    // Handle sleep times after midnight (e.g., 1 AM = next day)
    // If end hour is less than start hour, it means sleep is after midnight
    // In this case, use 23:59 as the end time for scheduling purposes
    if (dayEndHour <= dayStartHour) {
      dayEndHour = 23; // Schedule up to 11 PM when sleep is after midnight
    }

    // Start with full day
    final dayStart = DateTime(date.year, date.month, date.day, dayStartHour, 0);
    final dayEnd = DateTime(date.year, date.month, date.day, dayEndHour, 0);

    // If no blockers, return full day as one slot
    if (blockers.isEmpty) {
      return [TimeSlot(dayStart, dayEnd)];
    }

    // Sort blockers by start time
    final sortedBlockers = List<OneTimeTask>.from(blockers)
      ..sort((a, b) => a.scheduledStartTime.compareTo(b.scheduledStartTime));

    final availableSlots = <TimeSlot>[];
    DateTime currentTime = dayStart;

    for (final blocker in sortedBlockers) {
      final blockerStart = blocker.scheduledStartTime;
      final blockerEnd = blockerStart.add(Duration(minutes: blocker.duration));

      // Add slot before blocker if there's time
      if (currentTime.isBefore(blockerStart)) {
        availableSlots.add(TimeSlot(currentTime, blockerStart));
      }

      // Move current time to after blocker
      currentTime = blockerEnd;
    }

    // Add remaining time after last blocker
    if (currentTime.isBefore(dayEnd)) {
      availableSlots.add(TimeSlot(currentTime, dayEnd));
    }

    return availableSlots;
  }

  /// Calculate available time slots using dynamic wake/sleep times (ASYNC)
  Future<List<TimeSlot>> calculateAvailableSlotsAsync(
    DateTime date,
    List<OneTimeTask> blockers,
  ) async {
    final startHour = await _getDayStartHour(date);
    final endHour = await _getDayEndHour(date);

    return calculateAvailableSlots(
      date,
      blockers,
      startHour: startHour,
      endHour: endHour,
    );
  }

  /// Find the best time slot for a goal based on priority (PUBLIC)
  TimeSlot? findBestSlotForGoal({
    required Goal goal,
    required List<TimeSlot> availableSlots,
    required List<TimeSlot> usedSlots,
  }) {
    final requiredWithGap = goal.targetDuration + minTaskGapMinutes;
    final requiredWithoutGap = goal.targetDuration;

    // Get truly available slots (excluding used portions)
    final freeSlots = getFreeSlots(availableSlots, usedSlots);

    // Priority-based slot selection
    TimeSlot? result;
    if (goal.priorityIndex < 3) {
      // High priority → Morning (6 AM - 12 PM)
      result = _findSlotInTimeRange(freeSlots, 6, 12, requiredWithGap) ??
          _findFirstFittingSlot(freeSlots, requiredWithGap);
    } else if (goal.priorityIndex < 6) {
      // Medium priority → Afternoon (12 PM - 6 PM)
      result = _findSlotInTimeRange(freeSlots, 12, 18, requiredWithGap) ??
          _findFirstFittingSlot(freeSlots, requiredWithGap);
    } else {
      // Low priority → Evening (6 PM - 11 PM)
      result = _findSlotInTimeRange(freeSlots, 18, 23, requiredWithGap) ??
          _findFirstFittingSlot(freeSlots, requiredWithGap);
    }
    
    // If no slot found with gap, try without gap (for tight schedules / end of day)
    result ??= _findFirstFittingSlot(freeSlots, requiredWithoutGap);
    
    return result;
  }

  /// Get free slots by subtracting used slots from available slots (PUBLIC)
  List<TimeSlot> getFreeSlots(
    List<TimeSlot> availableSlots,
    List<TimeSlot> usedSlots,
  ) {
    if (usedSlots.isEmpty) return availableSlots;

    final freeSlots = <TimeSlot>[];

    for (final available in availableSlots) {
      DateTime currentStart = available.start;
      final availableEnd = available.end;

      // Sort used slots that overlap with this available slot
      final overlappingUsed =
          usedSlots
              .where(
                (used) =>
                    used.start.isBefore(availableEnd) &&
                    used.end.isAfter(currentStart),
              )
              .toList()
            ..sort((a, b) => a.start.compareTo(b.start));

      for (final used in overlappingUsed) {
        // Add free time before used slot
        if (currentStart.isBefore(used.start)) {
          freeSlots.add(TimeSlot(currentStart, used.start));
        }
        currentStart = used.end;
      }

      // Add remaining free time
      if (currentStart.isBefore(availableEnd)) {
        freeSlots.add(TimeSlot(currentStart, availableEnd));
      }
    }

    return freeSlots;
  }

  /// Find a slot within a specific time range (PRIVATE)
  TimeSlot? _findSlotInTimeRange(
    List<TimeSlot> slots,
    int startHour,
    int endHour,
    int requiredMinutes,
  ) {
    for (final slot in slots) {
      final slotHour = slot.start.hour;
      if (slotHour >= startHour &&
          slotHour < endHour &&
          slot.canFit(requiredMinutes)) {
        return slot;
      }
    }
    return null;
  }

  /// Find first slot that can fit the required duration (PRIVATE)
  TimeSlot? _findFirstFittingSlot(List<TimeSlot> slots, int requiredMinutes) {
    for (final slot in slots) {
      if (slot.canFit(requiredMinutes)) {
        return slot;
      }
    }
    return null;
  }

  /// Mark a time slot as used (PUBLIC)
  void markSlotAsUsed(ScheduledTask task, List<TimeSlot> usedSlots) {
    final start = task.scheduledStartTime;
    final end = start.add(Duration(minutes: task.duration + minTaskGapMinutes));
    usedSlots.add(TimeSlot(start, end));
  }

  /// Regenerate schedule for a date (delete old, create new)
  Future<List<ScheduledTask>> regenerateScheduleForDate(DateTime date) async {
    // Delete existing auto-generated tasks
    await scheduledTaskRepository.deleteAutoGeneratedTasksForDate(date);

    // Generate new schedule
    final newTasks = await scheduleForDate(date);

    // Save to database
    for (final task in newTasks) {
      await scheduledTaskRepository.createScheduledTask(task, allowDuplicates: false);
    }

    return newTasks;
  }

  /// Get scheduling statistics (PUBLIC)
  Future<Map<String, dynamic>> getSchedulingStats(DateTime date) async {
    final goals = await _getActiveGoalsForDate(date);
    final blockers = await _getBlockersForDate(date);
    final availableSlots = calculateAvailableSlots(date, blockers);

    final totalAvailableMinutes = availableSlots.fold(
      0,
      (sum, slot) => sum + slot.durationMinutes,
    );
    final requiredMinutes = goals.fold(
      0,
      (sum, goal) => sum + goal.targetDuration,
    );
    final blockedMinutes = blockers.fold(0, (sum, task) => sum + task.duration);

    return {
      'date': date.toIso8601String().split('T')[0],
      'total_goals': goals.length,
      'total_blockers': blockers.length,
      'available_minutes': totalAvailableMinutes,
      'required_minutes': requiredMinutes,
      'blocked_minutes': blockedMinutes,
      'can_fit_all': totalAvailableMinutes >= requiredMinutes,
      'utilization_percent': totalAvailableMinutes > 0
          ? (requiredMinutes / totalAvailableMinutes * 100).round()
          : 0,
    };
  }
}
