import 'package:flutter_test/flutter_test.dart';
import 'package:isar/isar.dart';
import 'package:goal_tracker/core/services/productivity_data_collector.dart';
import 'package:goal_tracker/data/models/scheduled_task.dart';
import 'package:goal_tracker/data/models/productivity_data.dart';
import 'package:goal_tracker/data/repositories/scheduled_task_repository.dart';
import 'package:goal_tracker/data/repositories/productivity_data_repository.dart';

void main() {
  late Isar isar;
  late ScheduledTaskRepository scheduledTaskRepository;
  late ProductivityDataRepository productivityDataRepository;
  late ProductivityDataCollector collector;

  setUpAll(() async {
    await Isar.initializeIsarCore(download: true);
  });

  setUp(() async {
    isar = await Isar.open(
      [ScheduledTaskSchema, ProductivityDataSchema],
      directory: '',
      name: 'test_collector_${DateTime.now().millisecondsSinceEpoch}',
    );

    scheduledTaskRepository = ScheduledTaskRepository(isar);
    productivityDataRepository = ProductivityDataRepository(isar);

    collector = ProductivityDataCollector(
      isar: isar,
      scheduledTaskRepository: scheduledTaskRepository,
      productivityDataRepository: productivityDataRepository,
    );
  });

  tearDown(() async {
    await isar.close(deleteFromDisk: true);
  });

  // Helper to create a test scheduled task
  Future<ScheduledTask> createTestTask({
    required String title,
    required DateTime scheduledDate,
    required int hour,
    required int duration,
    int goalId = 1,
    String schedulingMethod = 'rule-based',
    double? mlConfidence,
  }) async {
    final task = ScheduledTask()
      ..goalId = goalId
      ..title = title
      ..scheduledDate = DateTime(
        scheduledDate.year,
        scheduledDate.month,
        scheduledDate.day,
      )
      ..scheduledStartTime = DateTime(
        scheduledDate.year,
        scheduledDate.month,
        scheduledDate.day,
        hour,
      )
      ..originalScheduledTime = DateTime(
        scheduledDate.year,
        scheduledDate.month,
        scheduledDate.day,
        hour,
      )
      ..duration = duration
      ..colorHex = '#FF5733'
      ..iconName = 'fitness_center'
      ..schedulingMethod = schedulingMethod
      ..mlConfidence = mlConfidence
      ..isCompleted = false
      ..wasRescheduled = false
      ..rescheduleCount = 0
      ..isAutoGenerated = true
      ..createdAt = DateTime.now();

    final id = await scheduledTaskRepository.createScheduledTask(task);
    return (await scheduledTaskRepository.getScheduledTask(id))!;
  }

  group('ProductivityDataCollector', () {
    group('recordTaskCompletion', () {
      test('marks task as completed and creates productivity data', () async {
        final task = await createTestTask(
          title: 'Test Task',
          scheduledDate: DateTime(2024, 1, 15),
          hour: 9,
          duration: 60,
        );

        await collector.recordTaskCompletion(
          taskId: task.id,
          actualStartTime: DateTime(2024, 1, 15, 9, 15),
          actualDurationMinutes: 55,
          productivityRating: 4.0,
          notes: 'Great session!',
        );

        // Verify task is marked as completed
        final updatedTask = await scheduledTaskRepository.getScheduledTask(
          task.id,
        );
        expect(updatedTask!.isCompleted, true);
        expect(updatedTask.completedAt, isNotNull);
        expect(updatedTask.actualStartTime, DateTime(2024, 1, 15, 9, 15));
        expect(updatedTask.actualDuration, 55);
        expect(updatedTask.productivityRating, 4);
        expect(updatedTask.completionNotes, 'Great session!');

        // Verify productivity data was created
        final productivityData = await productivityDataRepository
            .getDataForGoal(task.goalId);
        expect(productivityData, hasLength(1));

        final data = productivityData.first;
        expect(data.goalId, task.goalId);
        expect(data.hourOfDay, 9);
        expect(data.productivityScore, 4.0);
        expect(data.wasCompleted, true);
        expect(data.actualDurationMinutes, 55);
      });

      test('calculates correct time slot type', () async {
        // Morning task (6-12)
        final morningTask = await createTestTask(
          title: 'Morning Task',
          scheduledDate: DateTime(2024, 1, 15),
          hour: 8,
          duration: 60,
          goalId: 1,
        );

        await collector.recordTaskCompletion(
          taskId: morningTask.id,
          actualStartTime: DateTime(2024, 1, 15, 8),
          actualDurationMinutes: 60,
          productivityRating: 4.0,
        );

        // Afternoon task (12-18)
        final afternoonTask = await createTestTask(
          title: 'Afternoon Task',
          scheduledDate: DateTime(2024, 1, 15),
          hour: 14,
          duration: 60,
          goalId: 2,
        );

        await collector.recordTaskCompletion(
          taskId: afternoonTask.id,
          actualStartTime: DateTime(2024, 1, 15, 14),
          actualDurationMinutes: 60,
          productivityRating: 3.0,
        );

        // Evening task (18-22)
        final eveningTask = await createTestTask(
          title: 'Evening Task',
          scheduledDate: DateTime(2024, 1, 15),
          hour: 19,
          duration: 60,
          goalId: 3,
        );

        await collector.recordTaskCompletion(
          taskId: eveningTask.id,
          actualStartTime: DateTime(2024, 1, 15, 19),
          actualDurationMinutes: 60,
          productivityRating: 5.0,
        );

        // Verify time slot types
        final morningData = await productivityDataRepository.getDataForGoal(1);
        expect(morningData.first.timeSlotType, 0); // Morning

        final afternoonData = await productivityDataRepository.getDataForGoal(
          2,
        );
        expect(afternoonData.first.timeSlotType, 1); // Afternoon

        final eveningData = await productivityDataRepository.getDataForGoal(3);
        expect(eveningData.first.timeSlotType, 2); // Evening
      });

      test('calculates minutes from scheduled correctly', () async {
        final task = await createTestTask(
          title: 'Test Task',
          scheduledDate: DateTime(2024, 1, 15),
          hour: 9,
          duration: 60,
        );

        // Started 30 minutes late
        await collector.recordTaskCompletion(
          taskId: task.id,
          actualStartTime: DateTime(2024, 1, 15, 9, 30),
          actualDurationMinutes: 60,
          productivityRating: 3.0,
        );

        final productivityData = await productivityDataRepository
            .getDataForGoal(task.goalId);
        expect(productivityData.first.minutesFromScheduled, 30);
      });

      test('handles non-existent task gracefully', () async {
        // Should not throw
        await collector.recordTaskCompletion(
          taskId: 99999,
          actualStartTime: DateTime.now(),
          actualDurationMinutes: 60,
          productivityRating: 4.0,
        );

        final allData = await productivityDataRepository.getDataCount();
        expect(allData, 0);
      });

      test('records weekend flag correctly', () async {
        // Saturday
        final saturdayTask = await createTestTask(
          title: 'Saturday Task',
          scheduledDate: DateTime(2024, 1, 20), // Saturday
          hour: 10,
          duration: 60,
          goalId: 1,
        );

        await collector.recordTaskCompletion(
          taskId: saturdayTask.id,
          actualStartTime: DateTime(2024, 1, 20, 10),
          actualDurationMinutes: 60,
          productivityRating: 4.0,
        );

        // Monday
        final mondayTask = await createTestTask(
          title: 'Monday Task',
          scheduledDate: DateTime(2024, 1, 15), // Monday
          hour: 10,
          duration: 60,
          goalId: 2,
        );

        await collector.recordTaskCompletion(
          taskId: mondayTask.id,
          actualStartTime: DateTime(2024, 1, 15, 10),
          actualDurationMinutes: 60,
          productivityRating: 4.0,
        );

        final saturdayData = await productivityDataRepository.getDataForGoal(1);
        expect(saturdayData.first.isWeekend, true);

        final mondayData = await productivityDataRepository.getDataForGoal(2);
        expect(mondayData.first.isWeekend, false);
      });
    });

    group('recordTaskReschedule', () {
      test('records reschedule and updates task', () async {
        final task = await createTestTask(
          title: 'Test Task',
          scheduledDate: DateTime(2024, 1, 15),
          hour: 9,
          duration: 60,
        );

        final newTime = DateTime(2024, 1, 15, 14, 0);
        await collector.recordTaskReschedule(
          taskId: task.id,
          newStartTime: newTime,
        );

        final updatedTask = await scheduledTaskRepository.getScheduledTask(
          task.id,
        );
        expect(updatedTask!.wasRescheduled, true);
        expect(updatedTask.rescheduledTo, newTime);
        expect(updatedTask.rescheduleCount, 1);
        expect(updatedTask.scheduledStartTime, newTime);
      });

      test('increments reschedule count on multiple reschedules', () async {
        final task = await createTestTask(
          title: 'Test Task',
          scheduledDate: DateTime(2024, 1, 15),
          hour: 9,
          duration: 60,
        );

        await collector.recordTaskReschedule(
          taskId: task.id,
          newStartTime: DateTime(2024, 1, 15, 11),
        );

        await collector.recordTaskReschedule(
          taskId: task.id,
          newStartTime: DateTime(2024, 1, 15, 14),
        );

        await collector.recordTaskReschedule(
          taskId: task.id,
          newStartTime: DateTime(2024, 1, 15, 16),
        );

        final updatedTask = await scheduledTaskRepository.getScheduledTask(
          task.id,
        );
        expect(updatedTask!.rescheduleCount, 3);
      });

      test('handles non-existent task gracefully', () async {
        // Should not throw
        await collector.recordTaskReschedule(
          taskId: 99999,
          newStartTime: DateTime.now(),
        );
      });
    });

    group('recordTaskSkipped', () {
      test('records skip with zero productivity score', () async {
        final task = await createTestTask(
          title: 'Skipped Task',
          scheduledDate: DateTime(2024, 1, 15),
          hour: 9,
          duration: 60,
        );

        await collector.recordTaskSkipped(taskId: task.id);

        final productivityData = await productivityDataRepository
            .getDataForGoal(task.goalId);
        expect(productivityData, hasLength(1));

        final data = productivityData.first;
        expect(data.productivityScore, 0.0);
        expect(data.wasCompleted, false);
        expect(data.actualDurationMinutes, 0);
      });

      test('handles non-existent task gracefully', () async {
        // Should not throw
        await collector.recordTaskSkipped(taskId: 99999);

        final allData = await productivityDataRepository.getDataCount();
        expect(allData, 0);
      });
    });

    group('getProductivityStats', () {
      test('returns has_data false for goal with no data', () async {
        final stats = await collector.getProductivityStats(999);

        expect(stats['has_data'], false);
        expect(stats['total_completions'], 0);
      });

      test('calculates correct statistics', () async {
        const goalId = 1;

        // Create and complete multiple tasks
        for (int i = 0; i < 5; i++) {
          final task = await createTestTask(
            title: 'Task $i',
            scheduledDate: DateTime(2024, 1, 15 + i),
            hour: 9,
            duration: 60,
            goalId: goalId,
          );

          await collector.recordTaskCompletion(
            taskId: task.id,
            actualStartTime: DateTime(2024, 1, 15 + i, 9),
            actualDurationMinutes: 60,
            productivityRating: 4.0, // All same rating
          );
        }

        // Skip one task
        final skippedTask = await createTestTask(
          title: 'Skipped Task',
          scheduledDate: DateTime(2024, 1, 20),
          hour: 9,
          duration: 60,
          goalId: goalId,
        );
        await collector.recordTaskSkipped(taskId: skippedTask.id);

        final stats = await collector.getProductivityStats(goalId);

        expect(stats['has_data'], true);
        expect(stats['total_completions'], 5);
        expect(stats['total_skips'], 1);
        expect(stats['avg_productivity'], 4.0);
        expect(stats['completion_rate'], closeTo(0.833, 0.01)); // 5/6
      });

      test('includes reschedule count', () async {
        const goalId = 1;

        final task = await createTestTask(
          title: 'Rescheduled Task',
          scheduledDate: DateTime(2024, 1, 15),
          hour: 9,
          duration: 60,
          goalId: goalId,
        );

        // Reschedule the task
        await collector.recordTaskReschedule(
          taskId: task.id,
          newStartTime: DateTime(2024, 1, 15, 14),
        );

        // Then complete it
        await collector.recordTaskCompletion(
          taskId: task.id,
          actualStartTime: DateTime(2024, 1, 15, 14),
          actualDurationMinutes: 60,
          productivityRating: 4.0,
        );

        final stats = await collector.getProductivityStats(goalId);

        expect(stats['has_data'], true);
        expect(stats['total_reschedules'], 1);
      });
    });

    group('ML data for ml-based tasks', () {
      test('stores ML metadata for ml-based scheduled tasks', () async {
        final task = await createTestTask(
          title: 'ML Scheduled Task',
          scheduledDate: DateTime(2024, 1, 15),
          hour: 9,
          duration: 60,
          schedulingMethod: 'ml-based',
          mlConfidence: 0.85,
        );

        await collector.recordTaskCompletion(
          taskId: task.id,
          actualStartTime: DateTime(2024, 1, 15, 9),
          actualDurationMinutes: 60,
          productivityRating: 4.5,
        );

        final productivityData = await productivityDataRepository
            .getDataForGoal(task.goalId);

        expect(productivityData, hasLength(1));
        // The collector should recognize this was ML-scheduled
        // (Implementation stores predictedScore for ML tasks)
      });
    });
  });
}
