// ignore_for_file: unused_local_variable

import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:isar/isar.dart';
import 'package:goal_tracker/features/timeline/presentation/providers/timeline_providers.dart';
import 'package:goal_tracker/features/one_time_tasks/presentation/providers/one_time_task_provider.dart'
    as one_time_task_providers;
import 'package:goal_tracker/core/services/database_service.dart';
import 'package:goal_tracker/data/models/one_time_task.dart';
import 'package:goal_tracker/data/models/scheduled_task.dart';
import 'package:goal_tracker/data/models/goal.dart';
import 'package:goal_tracker/data/models/milestone.dart';
import 'package:goal_tracker/data/models/task.dart';
import 'package:goal_tracker/data/models/productivity_data.dart';
import 'package:goal_tracker/data/repositories/one_time_task_repository.dart';
import 'package:goal_tracker/data/repositories/scheduled_task_repository.dart';
import 'package:goal_tracker/data/repositories/goal_repository.dart';
import 'package:goal_tracker/data/repositories/productivity_data_repository.dart';
import 'package:goal_tracker/features/timeline/domain/timeline_item.dart';

void main() {
  late Isar isar;
  late OneTimeTaskRepository oneTimeTaskRepository;
  late ScheduledTaskRepository scheduledTaskRepository;
  late GoalRepository goalRepository;
  late ProductivityDataRepository productivityDataRepository;
  late ProviderContainer container;

  setUpAll(() async {
    await Isar.initializeIsarCore(download: true);
  });

  setUp(() async {
    isar = await Isar.open(
      [
        OneTimeTaskSchema,
        ScheduledTaskSchema,
        GoalSchema,
        MilestoneSchema,
        TaskSchema,
        ProductivityDataSchema,
      ],
      directory: '',
      name: 'test_timeline_${DateTime.now().millisecondsSinceEpoch}',
    );

    oneTimeTaskRepository = OneTimeTaskRepository(isar);
    scheduledTaskRepository = ScheduledTaskRepository(isar);
    goalRepository = GoalRepository(isar);
    productivityDataRepository = ProductivityDataRepository(isar);

    // Create provider container with overrides
    // Override BOTH sets of providers - from database_service.dart AND from one_time_task_provider.dart
    container = ProviderContainer(
      overrides: [
        // Override the database_service.dart providers
        isarProvider.overrideWithValue(isar),
        oneTimeTaskRepositoryProvider.overrideWithValue(oneTimeTaskRepository),
        scheduledTaskRepositoryProvider.overrideWithValue(scheduledTaskRepository),
        goalRepositoryProvider.overrideWithValue(goalRepository),
        productivityDataRepositoryProvider.overrideWithValue(productivityDataRepository),
        // Override the one_time_task_provider.dart oneTimeTaskRepositoryProvider
        one_time_task_providers.oneTimeTaskRepositoryProvider.overrideWithValue(oneTimeTaskRepository),
      ],
    );
  });

  tearDown(() async {
    container.dispose();
    await isar.close(deleteFromDisk: true);
  });

  // Helper to create a one-time task
  Future<OneTimeTask> createOneTimeTask({
    required String title,
    required DateTime date,
    required int hour,
    required int duration,
    bool isCompleted = false,
  }) async {
    final task = OneTimeTask()
      ..title = title
      ..scheduledDate = DateTime(date.year, date.month, date.day)
      ..scheduledStartTime = DateTime(date.year, date.month, date.day, hour)
      ..duration = duration
      ..isCompleted = isCompleted
      ..createdAt = DateTime.now();

    await oneTimeTaskRepository.createOneTimeTask(task);
    return task;
  }

  // Helper to create a scheduled task
  Future<ScheduledTask> createScheduledTask({
    required String title,
    required DateTime date,
    required int hour,
    required int duration,
    int goalId = 1,
    bool isCompleted = false,
  }) async {
    final task = ScheduledTask()
      ..goalId = goalId
      ..title = title
      ..scheduledDate = DateTime(date.year, date.month, date.day)
      ..scheduledStartTime = DateTime(date.year, date.month, date.day, hour)
      ..originalScheduledTime = DateTime(date.year, date.month, date.day, hour)
      ..duration = duration
      ..colorHex = '#FF5733'
      ..iconName = 'fitness_center'
      ..schedulingMethod = 'rule-based'
      ..isCompleted = isCompleted
      ..wasRescheduled = false
      ..rescheduleCount = 0
      ..isAutoGenerated = true
      ..createdAt = DateTime.now();

    await scheduledTaskRepository.createScheduledTask(task);
    return task;
  }

  group('unifiedTimelineProvider', () {
    test('returns empty list when no tasks exist', () async {
      final date = DateTime(2024, 1, 15);

      final items = await container.read(
        unifiedTimelineProvider(date).future,
      );

      expect(items, isEmpty);
    });

    test('returns only one-time tasks when no scheduled tasks exist',
        () async {
      final date = DateTime(2024, 1, 15);

      await createOneTimeTask(
        title: 'Appointment',
        date: date,
        hour: 10,
        duration: 30,
      );

      final items = await container.read(
        unifiedTimelineProvider(date).future,
      );

      expect(items, hasLength(1));
      expect(items.first.type, TimelineItemType.oneTime);
      expect(items.first.title, 'Appointment');
    });

    test('returns only scheduled tasks when no one-time tasks exist',
        () async {
      final date = DateTime(2024, 1, 15);

      await createScheduledTask(
        title: 'Study Session',
        date: date,
        hour: 14,
        duration: 60,
      );

      final items = await container.read(
        unifiedTimelineProvider(date).future,
      );

      expect(items, hasLength(1));
      expect(items.first.type, TimelineItemType.scheduled);
      expect(items.first.title, 'Study Session');
    });

    test('merges both task types into unified timeline', () async {
      final date = DateTime(2024, 1, 15);

      await createOneTimeTask(
        title: 'Doctor Visit',
        date: date,
        hour: 10,
        duration: 30,
      );

      await createScheduledTask(
        title: 'Gym',
        date: date,
        hour: 16,
        duration: 60,
      );

      final items = await container.read(
        unifiedTimelineProvider(date).future,
      );

      expect(items, hasLength(2));
    });

    test('sorts merged timeline by scheduled time', () async {
      final date = DateTime(2024, 1, 15);

      // Create tasks out of order
      await createScheduledTask(
        title: 'Evening Task',
        date: date,
        hour: 18,
        duration: 60,
      );

      await createOneTimeTask(
        title: 'Morning Event',
        date: date,
        hour: 8,
        duration: 30,
      );

      await createScheduledTask(
        title: 'Afternoon Task',
        date: date,
        hour: 14,
        duration: 60,
      );

      final items = await container.read(
        unifiedTimelineProvider(date).future,
      );

      expect(items, hasLength(3));
      expect(items[0].scheduledTime.hour, 8); // Morning Event
      expect(items[1].scheduledTime.hour, 14); // Afternoon Task
      expect(items[2].scheduledTime.hour, 18); // Evening Task
    });

    test('preserves task type information in merged timeline', () async {
      final date = DateTime(2024, 1, 15);

      await createOneTimeTask(
        title: 'One-Time',
        date: date,
        hour: 10,
        duration: 30,
      );

      await createScheduledTask(
        title: 'Scheduled',
        date: date,
        hour: 14,
        duration: 60,
      );

      final items = await container.read(
        unifiedTimelineProvider(date).future,
      );

      final oneTimeItem = items.firstWhere((i) => i.title == 'One-Time');
      final scheduledItem = items.firstWhere((i) => i.title == 'Scheduled');

      expect(oneTimeItem.type, TimelineItemType.oneTime);
      expect(oneTimeItem.asOneTimeTask, isNotNull);
      expect(oneTimeItem.asScheduledTask, isNull);

      expect(scheduledItem.type, TimelineItemType.scheduled);
      expect(scheduledItem.asScheduledTask, isNotNull);
      expect(scheduledItem.asOneTimeTask, isNull);
    });

    test('does not include tasks from different dates', () async {
      final targetDate = DateTime(2024, 1, 15);
      final otherDate = DateTime(2024, 1, 16);

      await createOneTimeTask(
        title: 'Target Date Task',
        date: targetDate,
        hour: 10,
        duration: 30,
      );

      await createScheduledTask(
        title: 'Other Date Task',
        date: otherDate,
        hour: 14,
        duration: 60,
      );

      final items = await container.read(
        unifiedTimelineProvider(targetDate).future,
      );

      expect(items, hasLength(1));
      expect(items.first.title, 'Target Date Task');
    });

    test('includes both completed and incomplete tasks', () async {
      final date = DateTime(2024, 1, 15);

      await createOneTimeTask(
        title: 'Completed Task',
        date: date,
        hour: 10,
        duration: 30,
        isCompleted: true,
      );

      await createScheduledTask(
        title: 'Pending Task',
        date: date,
        hour: 14,
        duration: 60,
        isCompleted: false,
      );

      final items = await container.read(
        unifiedTimelineProvider(date).future,
      );

      expect(items, hasLength(2));

      final completedItem = items.firstWhere((i) => i.title == 'Completed Task');
      final pendingItem = items.firstWhere((i) => i.title == 'Pending Task');

      expect(completedItem.isCompleted, true);
      expect(pendingItem.isCompleted, false);
    });

    test('generates correct IDs with prefixes', () async {
      final date = DateTime(2024, 1, 15);

      final oneTimeTask = await createOneTimeTask(
        title: 'One-Time',
        date: date,
        hour: 10,
        duration: 30,
      );

      final scheduledTask = await createScheduledTask(
        title: 'Scheduled',
        date: date,
        hour: 14,
        duration: 60,
      );

      final items = await container.read(
        unifiedTimelineProvider(date).future,
      );

      final oneTimeItem = items.firstWhere((i) => i.title == 'One-Time');
      final scheduledItem = items.firstWhere((i) => i.title == 'Scheduled');

      expect(oneTimeItem.id, startsWith('ott_'));
      expect(scheduledItem.id, startsWith('st_'));
    });

    test('preserves duration from original tasks', () async {
      final date = DateTime(2024, 1, 15);

      await createOneTimeTask(
        title: 'Short Event',
        date: date,
        hour: 10,
        duration: 15,
      );

      await createScheduledTask(
        title: 'Long Session',
        date: date,
        hour: 14,
        duration: 120,
      );

      final items = await container.read(
        unifiedTimelineProvider(date).future,
      );

      final shortItem = items.firstWhere((i) => i.title == 'Short Event');
      final longItem = items.firstWhere((i) => i.title == 'Long Session');

      expect(shortItem.duration, 15);
      expect(longItem.duration, 120);
    });

    test('handles many tasks efficiently', () async {
      final date = DateTime(2024, 1, 15);

      // Create multiple tasks
      for (int i = 0; i < 10; i++) {
        await createOneTimeTask(
          title: 'Event $i',
          date: date,
          hour: 6 + i,
          duration: 30,
        );

        await createScheduledTask(
          title: 'Task $i',
          date: date,
          hour: 16 + (i % 6),
          duration: 60,
        );
      }

      final items = await container.read(
        unifiedTimelineProvider(date).future,
      );

      expect(items, hasLength(20));

      // Verify sorted order
      for (int i = 1; i < items.length; i++) {
        expect(
          items[i].scheduledTime.isAfter(items[i - 1].scheduledTime) ||
              items[i].scheduledTime.isAtSameMomentAs(items[i - 1].scheduledTime),
          true,
        );
      }
    });
  });

  group('tasksForDateProvider', () {
    test('returns one-time tasks for a date', () async {
      final date = DateTime(2024, 1, 15);

      await createOneTimeTask(
        title: 'Test Event',
        date: date,
        hour: 10,
        duration: 30,
      );

      final tasks = await container.read(
        one_time_task_providers.tasksForDateProvider(date).future,
      );

      expect(tasks, hasLength(1));
      expect(tasks.first.title, 'Test Event');
    });
  });
}
