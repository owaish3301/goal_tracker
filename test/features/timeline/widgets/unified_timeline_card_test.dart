import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:goal_tracker/features/timeline/presentation/widgets/unified_timeline_card.dart';
import 'package:goal_tracker/features/timeline/domain/timeline_item.dart';
import 'package:goal_tracker/data/models/one_time_task.dart';
import 'package:goal_tracker/data/models/scheduled_task.dart';

void main() {
  // Helper to create a test OneTimeTask
  OneTimeTask createOneTimeTask({
    int id = 1,
    String title = 'One-Time Task',
    int hour = 10,
    int duration = 30,
    String? colorHex,
    bool isCompleted = false,
  }) {
    final now = DateTime.now();
    final task = OneTimeTask()
      ..id = id
      ..title = title
      ..scheduledDate = DateTime(now.year, now.month, now.day)
      ..scheduledStartTime = DateTime(now.year, now.month, now.day, hour)
      ..duration = duration
      ..colorHex = colorHex
      ..isCompleted = isCompleted
      ..createdAt = DateTime.now();

    return task;
  }

  // Helper to create a test ScheduledTask
  ScheduledTask createScheduledTask({
    int id = 1,
    String title = 'Scheduled Task',
    int hour = 14,
    int duration = 60,
    String colorHex = '#FF5733',
    String schedulingMethod = 'rule-based',
    bool isCompleted = false,
  }) {
    final now = DateTime.now();
    final task = ScheduledTask()
      ..id = id
      ..goalId = 1
      ..title = title
      ..scheduledDate = DateTime(now.year, now.month, now.day)
      ..scheduledStartTime = DateTime(now.year, now.month, now.day, hour)
      ..originalScheduledTime = DateTime(now.year, now.month, now.day, hour)
      ..duration = duration
      ..colorHex = colorHex
      ..iconName = 'fitness_center'
      ..schedulingMethod = schedulingMethod
      ..isCompleted = isCompleted
      ..wasRescheduled = false
      ..rescheduleCount = 0
      ..isAutoGenerated = true
      ..createdAt = DateTime.now();

    return task;
  }

  // Helper to wrap widget with necessary providers
  Widget createTestWidget({
    required TimelineItem item,
    VoidCallback? onCompleted,
  }) {
    return ProviderScope(
      child: MaterialApp(
        theme: ThemeData.dark(),
        home: Scaffold(
          body: UnifiedTimelineCard(
            item: item,
            onCompleted: onCompleted,
          ),
        ),
      ),
    );
  }

  group('UnifiedTimelineCard', () {
    group('TimelineItem from OneTimeTask', () {
      testWidgets('renders OneTimeTask correctly', (tester) async {
        final oneTimeTask = createOneTimeTask(title: 'Doctor Appointment');
        final item = TimelineItem.fromOneTimeTask(oneTimeTask);

        await tester.pumpWidget(createTestWidget(item: item));

        expect(find.text('Doctor Appointment'), findsOneWidget);
      });

      testWidgets('OneTimeTask item has correct type', (tester) async {
        final oneTimeTask = createOneTimeTask();
        final item = TimelineItem.fromOneTimeTask(oneTimeTask);

        expect(item.type, TimelineItemType.oneTime);
        expect(item.asOneTimeTask, isNotNull);
        expect(item.asScheduledTask, isNull);
      });

      testWidgets('OneTimeTask item preserves ID with prefix', (tester) async {
        final oneTimeTask = createOneTimeTask(id: 42);
        final item = TimelineItem.fromOneTimeTask(oneTimeTask);

        expect(item.id, 'ott_42');
      });

      testWidgets('OneTimeTask item preserves scheduled time', (tester) async {
        final oneTimeTask = createOneTimeTask(hour: 15);
        final item = TimelineItem.fromOneTimeTask(oneTimeTask);

        expect(item.scheduledTime.hour, 15);
      });

      testWidgets('OneTimeTask item preserves duration', (tester) async {
        final oneTimeTask = createOneTimeTask(duration: 45);
        final item = TimelineItem.fromOneTimeTask(oneTimeTask);

        expect(item.duration, 45);
      });

      testWidgets('OneTimeTask uses default color when null', (tester) async {
        final oneTimeTask = createOneTimeTask(colorHex: null);
        final item = TimelineItem.fromOneTimeTask(oneTimeTask);

        expect(item.colorHex, '#C6F432'); // Default color
      });

      testWidgets('OneTimeTask preserves completion status', (tester) async {
        final completedTask = createOneTimeTask(isCompleted: true);
        final item = TimelineItem.fromOneTimeTask(completedTask);

        expect(item.isCompleted, true);
      });
    });

    group('TimelineItem from ScheduledTask', () {
      testWidgets('renders ScheduledTask correctly', (tester) async {
        final scheduledTask = createScheduledTask(title: 'Study Session');
        final item = TimelineItem.fromScheduledTask(scheduledTask);

        await tester.pumpWidget(createTestWidget(item: item));

        expect(find.text('Study Session'), findsOneWidget);
      });

      testWidgets('ScheduledTask item has correct type', (tester) async {
        final scheduledTask = createScheduledTask();
        final item = TimelineItem.fromScheduledTask(scheduledTask);

        expect(item.type, TimelineItemType.scheduled);
        expect(item.asScheduledTask, isNotNull);
        expect(item.asOneTimeTask, isNull);
      });

      testWidgets('ScheduledTask item preserves ID with prefix', (tester) async {
        final scheduledTask = createScheduledTask(id: 99);
        final item = TimelineItem.fromScheduledTask(scheduledTask);

        expect(item.id, 'st_99');
      });

      testWidgets('ScheduledTask item preserves scheduled time', (tester) async {
        final scheduledTask = createScheduledTask(hour: 18);
        final item = TimelineItem.fromScheduledTask(scheduledTask);

        expect(item.scheduledTime.hour, 18);
      });

      testWidgets('ScheduledTask item preserves duration', (tester) async {
        final scheduledTask = createScheduledTask(duration: 90);
        final item = TimelineItem.fromScheduledTask(scheduledTask);

        expect(item.duration, 90);
      });

      testWidgets('ScheduledTask preserves icon name', (tester) async {
        final scheduledTask = createScheduledTask();
        final item = TimelineItem.fromScheduledTask(scheduledTask);

        expect(item.iconName, 'fitness_center');
      });

      testWidgets('ScheduledTask preserves completion status', (tester) async {
        final completedTask = createScheduledTask(isCompleted: true);
        final item = TimelineItem.fromScheduledTask(completedTask);

        expect(item.isCompleted, true);
      });
    });

    group('Card delegation', () {
      testWidgets('delegates OneTimeTask to OneTimeTaskCard', (tester) async {
        final oneTimeTask = createOneTimeTask(title: 'Laundry');
        final item = TimelineItem.fromOneTimeTask(oneTimeTask);

        await tester.pumpWidget(createTestWidget(item: item));

        // The card should render the title
        expect(find.text('Laundry'), findsOneWidget);
      });

      testWidgets('delegates ScheduledTask to ScheduledTaskCard',
          (tester) async {
        final scheduledTask = createScheduledTask(title: 'Gym Workout');
        final item = TimelineItem.fromScheduledTask(scheduledTask);

        await tester.pumpWidget(createTestWidget(item: item));

        // The card should render the title
        expect(find.text('Gym Workout'), findsOneWidget);
      });

      testWidgets('ML badge shown for ML-scheduled tasks', (tester) async {
        final scheduledTask = createScheduledTask(
          title: 'ML Task',
          schedulingMethod: 'ml-based',
        );
        final item = TimelineItem.fromScheduledTask(scheduledTask);

        await tester.pumpWidget(createTestWidget(item: item));

        expect(find.text('ML'), findsOneWidget);
      });
    });

    group('Timeline ordering', () {
      test('TimelineItems can be sorted by scheduled time', () {
        final task1 = createOneTimeTask(hour: 14);
        final task2 = createScheduledTask(hour: 9);
        final task3 = createOneTimeTask(hour: 11);

        final items = [
          TimelineItem.fromOneTimeTask(task1),
          TimelineItem.fromScheduledTask(task2),
          TimelineItem.fromOneTimeTask(task3),
        ];

        items.sort((a, b) => a.scheduledTime.compareTo(b.scheduledTime));

        expect(items[0].scheduledTime.hour, 9);
        expect(items[1].scheduledTime.hour, 11);
        expect(items[2].scheduledTime.hour, 14);
      });

      test('Mixed task types can be combined in timeline', () {
        final oneTimeTask = createOneTimeTask(title: 'Appointment');
        final scheduledTask = createScheduledTask(title: 'Study');

        final items = [
          TimelineItem.fromOneTimeTask(oneTimeTask),
          TimelineItem.fromScheduledTask(scheduledTask),
        ];

        expect(items, hasLength(2));
        expect(items[0].type, TimelineItemType.oneTime);
        expect(items[1].type, TimelineItemType.scheduled);
      });
    });

    group('Original task access', () {
      test('asOneTimeTask returns original task for OneTimeTask items', () {
        final originalTask = createOneTimeTask(title: 'Original');
        final item = TimelineItem.fromOneTimeTask(originalTask);

        final retrieved = item.asOneTimeTask;
        expect(retrieved, isNotNull);
        expect(retrieved!.title, 'Original');
        expect(retrieved.id, originalTask.id);
      });

      test('asScheduledTask returns original task for ScheduledTask items', () {
        final originalTask = createScheduledTask(title: 'Original Scheduled');
        final item = TimelineItem.fromScheduledTask(originalTask);

        final retrieved = item.asScheduledTask;
        expect(retrieved, isNotNull);
        expect(retrieved!.title, 'Original Scheduled');
        expect(retrieved.id, originalTask.id);
      });

      test('asOneTimeTask returns null for ScheduledTask items', () {
        final scheduledTask = createScheduledTask();
        final item = TimelineItem.fromScheduledTask(scheduledTask);

        expect(item.asOneTimeTask, isNull);
      });

      test('asScheduledTask returns null for OneTimeTask items', () {
        final oneTimeTask = createOneTimeTask();
        final item = TimelineItem.fromOneTimeTask(oneTimeTask);

        expect(item.asScheduledTask, isNull);
      });
    });
  });
}
