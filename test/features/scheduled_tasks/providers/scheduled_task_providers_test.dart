import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:isar/isar.dart';
import 'package:goal_tracker/features/scheduled_tasks/presentation/providers/scheduled_task_providers.dart';
import 'package:goal_tracker/core/providers/scheduler_providers.dart';
import 'package:goal_tracker/core/services/database_service.dart';
import 'package:goal_tracker/data/models/goal.dart';
import 'package:goal_tracker/data/models/milestone.dart';
import 'package:goal_tracker/data/models/task.dart';
import 'package:goal_tracker/data/models/one_time_task.dart';
import 'package:goal_tracker/data/models/scheduled_task.dart';
import 'package:goal_tracker/data/models/productivity_data.dart';
import 'package:goal_tracker/data/repositories/goal_repository.dart';
import 'package:goal_tracker/data/repositories/one_time_task_repository.dart';
import 'package:goal_tracker/data/repositories/scheduled_task_repository.dart';
import 'package:goal_tracker/data/repositories/productivity_data_repository.dart';

void main() {
  late Isar isar;
  late GoalRepository goalRepository;
  late OneTimeTaskRepository oneTimeTaskRepository;
  late ScheduledTaskRepository scheduledTaskRepository;
  late ProductivityDataRepository productivityDataRepository;
  late ProviderContainer container;

  setUpAll(() async {
    await Isar.initializeIsarCore(download: true);
  });

  setUp(() async {
    isar = await Isar.open(
      [
        GoalSchema,
        MilestoneSchema,
        TaskSchema,
        OneTimeTaskSchema,
        ScheduledTaskSchema,
        ProductivityDataSchema,
      ],
      directory: '',
      name: 'test_providers_${DateTime.now().millisecondsSinceEpoch}',
    );

    goalRepository = GoalRepository(isar);
    oneTimeTaskRepository = OneTimeTaskRepository(isar);
    scheduledTaskRepository = ScheduledTaskRepository(isar);
    productivityDataRepository = ProductivityDataRepository(isar);

    // Create provider container with overrides
    container = ProviderContainer(
      overrides: [
        isarProvider.overrideWithValue(isar),
        goalRepositoryProvider.overrideWithValue(goalRepository),
        oneTimeTaskRepositoryProvider.overrideWithValue(oneTimeTaskRepository),
        scheduledTaskRepositoryProvider.overrideWithValue(scheduledTaskRepository),
        productivityDataRepositoryProvider.overrideWithValue(productivityDataRepository),
      ],
    );
  });

  tearDown(() async {
    container.dispose();
    await isar.close(deleteFromDisk: true);
  });

  // Helper to create a test goal
  Future<Goal> createTestGoal({
    required String title,
    required List<int> frequency,
    required int targetDuration,
    int priorityIndex = 0,
  }) async {
    final goal = Goal()
      ..title = title
      ..frequency = frequency
      ..targetDuration = targetDuration
      ..priorityIndex = priorityIndex
      ..colorHex = '#FF5733'
      ..iconName = 'fitness_center'
      ..isActive = true
      ..createdAt = DateTime.now();

    await goalRepository.createGoal(goal);
    return goal;
  }

  // Helper to create a scheduled task
  Future<ScheduledTask> createScheduledTask({
    required String title,
    required DateTime date,
    required int hour,
    required int duration,
    int goalId = 1,
    bool isAutoGenerated = true,
  }) async {
    final task = ScheduledTask()
      ..goalId = goalId
      ..title = title
      ..scheduledDate = DateTime(date.year, date.month, date.day)
      ..scheduledStartTime = DateTime(date.year, date.month, date.day, hour)
      ..originalScheduledTime = DateTime(date.year, date.month, date.day, hour)
      ..duration = duration
      ..colorHex = '#FF5733'
      ..iconName = 'fitness_center'
      ..schedulingMethod = 'rule-based'
      ..isCompleted = false
      ..wasRescheduled = false
      ..rescheduleCount = 0
      ..isAutoGenerated = isAutoGenerated
      ..createdAt = DateTime.now();

    await scheduledTaskRepository.createScheduledTask(task);
    return task;
  }

  group('scheduledTasksForDateProvider', () {
    test('returns empty list when no tasks exist', () async {
      final date = DateTime(2024, 1, 15);

      final tasks = await container.read(
        scheduledTasksForDateProvider(date).future,
      );

      expect(tasks, isEmpty);
    });

    test('returns tasks for the specified date', () async {
      final date = DateTime(2024, 1, 15);

      await createScheduledTask(
        title: 'Task 1',
        date: date,
        hour: 9,
        duration: 60,
      );

      await createScheduledTask(
        title: 'Task 2',
        date: date,
        hour: 14,
        duration: 30,
      );

      final tasks = await container.read(
        scheduledTasksForDateProvider(date).future,
      );

      expect(tasks, hasLength(2));
    });

    test('does not return tasks from different date', () async {
      final targetDate = DateTime(2024, 1, 15);
      final otherDate = DateTime(2024, 1, 16);

      await createScheduledTask(
        title: 'Task on target date',
        date: targetDate,
        hour: 9,
        duration: 60,
      );

      await createScheduledTask(
        title: 'Task on other date',
        date: otherDate,
        hour: 9,
        duration: 60,
      );

      final tasks = await container.read(
        scheduledTasksForDateProvider(targetDate).future,
      );

      expect(tasks, hasLength(1));
      expect(tasks.first.title, 'Task on target date');
    });

    test('returns tasks sorted by scheduled time', () async {
      final date = DateTime(2024, 1, 15);

      await createScheduledTask(
        title: 'Afternoon Task',
        date: date,
        hour: 14,
        duration: 60,
      );

      await createScheduledTask(
        title: 'Morning Task',
        date: date,
        hour: 8,
        duration: 60,
      );

      final tasks = await container.read(
        scheduledTasksForDateProvider(date).future,
      );

      expect(tasks, hasLength(2));
      expect(tasks[0].title, 'Morning Task');
      expect(tasks[1].title, 'Afternoon Task');
    });
  });

  group('generateScheduleProvider', () {
    test('returns existing schedule if one exists', () async {
      final date = DateTime(2024, 1, 15); // Monday

      // Create existing scheduled task
      await createScheduledTask(
        title: 'Existing Task',
        date: date,
        hour: 10,
        duration: 60,
      );

      final tasks = await container.read(
        generateScheduleProvider(date).future,
      );

      expect(tasks, hasLength(1));
      expect(tasks.first.title, 'Existing Task');
    });

    test('generates new schedule when none exists', () async {
      final date = DateTime(2024, 1, 15); // Monday (weekday = 1, dayOfWeek = 0)

      // Create a goal for Monday
      await createTestGoal(
        title: 'Monday Goal',
        frequency: [0], // Monday
        targetDuration: 60,
      );

      final tasks = await container.read(
        generateScheduleProvider(date).future,
      );

      expect(tasks, hasLength(1));
      expect(tasks.first.title, 'Monday Goal');
    });

    test('saves generated tasks to database', () async {
      final date = DateTime(2024, 1, 15); // Monday

      await createTestGoal(
        title: 'Test Goal',
        frequency: [0], // Monday
        targetDuration: 60,
      );

      await container.read(generateScheduleProvider(date).future);

      // Verify tasks were saved
      final savedTasks = await scheduledTaskRepository.getScheduledTasksForDate(date);
      expect(savedTasks, hasLength(1));
    });

    test('does not generate duplicates on second call', () async {
      final date = DateTime(2024, 1, 15); // Monday

      await createTestGoal(
        title: 'Test Goal',
        frequency: [0],
        targetDuration: 60,
      );

      // First call
      await container.read(generateScheduleProvider(date).future);

      // Create new container to avoid caching
      final container2 = ProviderContainer(
        overrides: [
          isarProvider.overrideWithValue(isar),
          goalRepositoryProvider.overrideWithValue(goalRepository),
          oneTimeTaskRepositoryProvider.overrideWithValue(oneTimeTaskRepository),
          scheduledTaskRepositoryProvider.overrideWithValue(scheduledTaskRepository),
          productivityDataRepositoryProvider.overrideWithValue(productivityDataRepository),
        ],
      );

      // Second call
      await container2.read(generateScheduleProvider(date).future);

      // Should still have only 1 task
      final savedTasks = await scheduledTaskRepository.getScheduledTasksForDate(date);
      expect(savedTasks, hasLength(1));

      container2.dispose();
    });
  });

  group('hybridSchedulerProvider', () {
    test('creates HybridScheduler with correct dependencies', () {
      final scheduler = container.read(hybridSchedulerProvider);

      expect(scheduler, isNotNull);
    });
  });

  group('ruleBasedSchedulerProvider', () {
    test('creates RuleBasedScheduler with correct dependencies', () {
      final scheduler = container.read(ruleBasedSchedulerProvider);

      expect(scheduler, isNotNull);
    });
  });

  group('patternBasedMLServiceProvider', () {
    test('creates PatternBasedMLService with correct dependencies', () {
      final mlService = container.read(patternBasedMLServiceProvider);

      expect(mlService, isNotNull);
      expect(mlService.predictorName, 'Pattern-Based ML');
    });
  });

  group('schedulingStatsProvider', () {
    test('returns stats for a date', () async {
      final date = DateTime(2024, 1, 15);

      await createTestGoal(
        title: 'Goal 1',
        frequency: [0],
        targetDuration: 60,
      );

      final stats = await container.read(
        schedulingStatsProvider(date).future,
      );

      expect(stats, isNotNull);
      expect(stats.containsKey('total_goals'), true);
    });
  });

  group('hybridSchedulingStatsProvider', () {
    test('returns stats with ML coverage info', () async {
      final date = DateTime(2024, 1, 15);

      await createTestGoal(
        title: 'Goal 1',
        frequency: [0],
        targetDuration: 60,
      );

      final stats = await container.read(
        hybridSchedulingStatsProvider(date).future,
      );

      expect(stats, isNotNull);
      expect(stats['ml_predictor'], 'Pattern-Based ML');
      expect(stats.containsKey('goals_with_ml_data'), true);
      expect(stats.containsKey('ml_coverage_percent'), true);
    });
  });
}
